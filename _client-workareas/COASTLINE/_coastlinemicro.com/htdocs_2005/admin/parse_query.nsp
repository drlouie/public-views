#!/usr/bin/perl5 -w

if ($ENV{'REQUEST_METHOD'} eq 'GET') {
    # Split the name-value pairs
    @pairs = split(/&/, $ENV{'QUERY_STRING'});
}
elsif ($ENV{'REQUEST_METHOD'} eq 'POST') {
    # Get the input
    read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});
 
    # Split the name-value pairs
    @pairs = split(/&/, $buffer);
}
	
# For each name-value pair:                                              #
foreach $pair (@pairs) {

   # Split the pair up into individual variables.                       #
   local($name, $value) = split(/=/, $pair);
 
   # Decode the form encoding on the name and value variables.          #
   $name =~ tr/+/ /;
   $name =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;

   $value =~ tr/+/ /;
   $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;

   # If they try to include server side includes, erase them, so they
   # aren't a security risk if the html gets returned.  Another 
   # security hole plugged up.
   $value =~ s/<!--(.|\n)*-->//g;

   # If the field name has been specified in the %Config array, it will #
   # return a 1 for defined($Config{$name}}) and we should associate    #
   # this value with the appropriate configuration variable.  If this   #
   # is not a configuration form field, put it into the associative     #
   # array %Form, appending the value with a ', ' if there is already a #
   # value present.  We also save the order of the form fields in the   #
   # @Field_Order array so we can use this order for the generic sort.  #
       if ($FORM{$name} && $value) {
           $FORM{$name} = "$FORM{$name}, $value";
       }
       elsif ($value) {
           push(@Field_Order,$name);
           $FORM{$name} = $value;
       }
}

1;